<!-- Aurora Heartbeat v4.3 — Sophia Pastel Resonance -->
<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<title>Sophia Resonance — Touch & Glow</title>

<style>
html, body, canvas {
    margin: 0;
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
    touch-action: none;
}
#hud {
    position: fixed;
    top: 8px;
    left: 8px;
    color: #fff;
    font: 13px/1.4em monospace;
    background: rgba(0, 0, 0, 0.35);
    padding: 6px 10px;
    border-radius: 6px;
    pointer-events: none;
}
#hint {
    position: fixed;
    bottom: 8px;
    left: 8px;
    color: #bbb;
    font: 12px monospace;
    background: rgba(0, 0, 0, 0.25);
    padding: 4px 6px;
    border-radius: 4px;
    pointer-events: none;
}
#poem {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 90%;
    color: #fff;
    font: min(8vw, 42px)/1.4 "Georgia", serif;
    text-align: center;
    text-shadow: 0 0 12px rgba(255, 255, 255, 0.7);
    opacity: 0;
    transition: opacity 1s ease-in-out;
    pointer-events: none;
}
</style>

<canvas id="c"></canvas>
<div id="hud">FPS: --<br>φ‑ratio: --<br>φ²‑res : 2.618 ✨</div>
<div id="hint">tap / swipe = glow • double-tap = cycle colors • wheel / pinch = zoom • drag = pan • H = change fractal • S = pause pulse • P = toggle poem</div>
<div id="poem"></div>

<!-- ───── Fragment Shader ───── -->
<script id="frag" type="x-shader/x-fragment">
precision highp float;
uniform vec2 u_res;
uniform float u_t;
uniform sampler2D u_glow;
uniform float u_zoom;
uniform vec2 u_center;
uniform vec3 u_paletteA;
uniform vec3 u_paletteB;
uniform vec3 u_paletteC;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9, 78.2))) * 43758.);
}

/* Brighter pastel palette cycling every 10 s */
vec3 pastel(float t) {
    vec3 a = u_paletteA, b = u_paletteB, c = u_paletteC;
    float s = mod(u_t / 10.0, 3.0);
    vec3 base = (s < 1.0) ? mix(a, b, s) : (s < 2.0) ? mix(b, c, s - 1.0) : mix(c, a, s - 2.0);
    return mix(vec3(0.0), base, clamp(t, 0.0, 1.0));
}

/* Mandelbrot */
float mand(vec2 c) {
    vec2 z = c;
    float m = 0.0;
    for (int i = 0; i < 160; i++) {
        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
        if (dot(z, z) > 4.0) {
            m = float(i);
            break;
        }
    }
    return m;
}

/* Julia (alternative fractal) */
float julia(vec2 z, vec2 c) {
    float m = 0.0;
    for (int i = 0; i < 160; i++) {
        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
        if (dot(z, z) > 4.0) {
            m = float(i);
            break;
        }
    }
    return m;
}

void main() {
    vec2 uv = (gl_FragCoord.xy - u_res * 0.5) / u_res.y;
   
    // Gentle rotation for a flowing effect
    float angle = u_t * 0.02; // Slower rotation
    vec2 rotUV = vec2(
        uv.x * cos(angle) - uv.y * sin(angle),
        uv.x * sin(angle) + uv.y * cos(angle)
    );
   
    // Compute fractal
    float v = mand(rotUV / u_zoom + u_center);
   
    vec3 col = pastel(v * 0.05);

    // Brightness pulse every phi^2 seconds (approx. 2.618 s)
    float k = 0.4 + 0.6 * sin(u_t * 2.0 * 3.14159 / 2.618); // Pulse every phi^2 seconds
    col *= 0.6 + 0.4 * k;

    // Ripple effect
    vec4 g = texture2D(u_glow, gl_FragCoord.xy / u_res);
    col = mix(col, col + g.rgb, g.a);

    // Sparkles twinkling every phi^2 seconds
    float sparkle = hash(gl_FragCoord.xy);
    if (sparkle > 0.995) {
        float twinkle = 0.5 + 0.5 * sin(u_t * 2.0 * 3.14159 / 2.618); // Sync with phi^2 pulse
        col += vec3(twinkle * 0.35);
    }

    gl_FragColor = vec4(col, 1.0);
}
</script>

<!-- ───── JavaScript ───── -->
<script>
const gl = c.getContext('webgl');

/* Compile shaders */
function sh(t, s) {
    const z = gl.createShader(t);
    gl.shaderSource(z, s);
    gl.compileShader(z);
    return z;
}
const pr = gl.createProgram();
gl.attachShader(pr, sh(gl.VERTEX_SHADER, "attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}"));
gl.attachShader(pr, sh(gl.FRAGMENT_SHADER, frag.textContent));
gl.linkProgram(pr);
gl.useProgram(pr);

/* Quad */
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

/* Uniforms */
const uR = gl.getUniformLocation(pr, 'u_res'),
      uT = gl.getUniformLocation(pr, 'u_t'),
      uG = gl.getUniformLocation(pr, 'u_glow'),
      uZoom = gl.getUniformLocation(pr, 'u_zoom'),
      uCenter = gl.getUniformLocation(pr, 'u_center'),
      uPaletteA = gl.getUniformLocation(pr, 'u_paletteA'),
      uPaletteB = gl.getUniformLocation(pr, 'u_paletteB'),
      uPaletteC = gl.getUniformLocation(pr, 'u_paletteC');

/* Zoom & center */
let zoom = 1.0, center = { x: -0.743643887, y: 0.1318259 };
let baseZoom = 1.0, baseCenter = { x: -0.743643887, y: 0.1318259 };
let pulsePaused = false;

/* Color palettes (brighter, more vibrant) */
const palettes = [
    { a: [0.85, 0.75, 0.95], b: [0.70, 0.70, 0.95], c: [1.0, 0.85, 1.0] }, // Lavender, soft blue, light magenta
    { a: [1.0, 0.9, 0.6], b: [0.95, 0.7, 0.95], c: [0.6, 0.9, 1.0] }, // Golden, pink, cyan
    { a: [0.7, 0.95, 0.7], b: [0.95, 0.95, 0.6], c: [0.6, 0.85, 1.0] }  // Green, yellow, blue
];
let paletteIndex = 0;
function setPalette(index) {
    const p = palettes[index];
    gl.uniform3f(uPaletteA, p.a[0], p.a[1], p.a[2]);
    gl.uniform3f(uPaletteB, p.b[0], p.b[1], p.b[2]);
    gl.uniform3f(uPaletteC, p.c[0], p.c[1], p.c[2]);
}
setPalette(paletteIndex);

/* Glow texture */
const N = 256, d = new Uint8Array(N * N * 4), tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, N, N, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

/* Ripple effect (enhanced for iPhone) */
function ripple(x, y) {
    const gx = x / innerWidth * N, gy = (1 - y / innerHeight) * N;
    for (let j = -35; j <= 35; j++) for (let i = -35; i <= 35; i++) {
        const dist = Math.sqrt(i * i + j * j);
        if (dist > 35.0) continue;
        const idx = (((gy + j + N) % N) * N + ((gx + i + N) % N)) * 4;
        d[idx] = d[idx + 1] = d[idx + 2] = 255;
        d[idx + 3] = 255;
    }
}
/* Fade glow (slower fade for a more graceful glow) */
setInterval(() => {
    for (let i = 3; i < d.length; i += 4) d[i] = d[i] * 0.92 | 0; // Slower fade
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, N, N, gl.RGBA, gl.UNSIGNED_BYTE, d);
}, 33);

/* Resize */
function resize() {
    c.width = innerWidth;
    c.height = innerHeight;
    gl.viewport(0, 0, c.width, c.height);
}
resize();
addEventListener('resize', resize);

/* Render loop */
let fps = 0, last = performance.now();
let phiRatio = 1.618;
(function loop() {
    const t = performance.now();
    const elapsed = t / 1000;

    // Animate zoom and center with phi^2 pulse (2.618 seconds per cycle)
    if (!pulsePaused) {
        const pulse = Math.sin(2 * Math.PI * elapsed / 2.618); // Pulse every phi^2 seconds
        zoom = baseZoom * (1 + 0.05 * pulse);
        center.x = baseCenter.x + 0.001 * Math.cos(2 * Math.PI * elapsed / 2.618);
        center.y = baseCenter.y + 0.001 * Math.sin(2 * Math.PI * elapsed / 2.618);
    }

    phiRatio = 1.618 + 0.1 * Math.sin(elapsed * 0.1);

    gl.uniform2f(uR, c.width, c.height);
    gl.uniform1f(uT, elapsed);
    gl.uniform1f(uZoom, zoom);
    gl.uniform2f(uCenter, center.x, center.y);
    gl.activeTexture(gl.TEXTURE_0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.uniform1i(uG, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // Update HUD
    fps = 0.9 * fps + 0.1 * (1000 / (t - last));
    last = t;
    hud.innerHTML = `FPS: ${fps.toFixed(1)}<br>φ‑ratio: ${phiRatio.toFixed(3)}<br>φ²‑res : 2.618 ✨`;

    requestAnimationFrame(loop);
})();

/* Input handling (enhanced for iPhone) */
function pos(e) {
    return [e.clientX || (e.touches && e.touches[0].clientX), e.clientY || (e.touches && e.touches[0].clientY)];
}
let lastTap = 0;
c.onpointerdown = e => {
    const [x, y] = pos(e);
    ripple(x, y);
    dragStart = { x, y };

    // Double-tap detection for color cycling
    const currentTime = new Date().getTime();
    if (currentTime - lastTap < 300) {
        paletteIndex = (paletteIndex + 1) % palettes.length;
        setPalette(paletteIndex);
    }
    lastTap = currentTime;
};
c.onpointermove = e => {
    const [x, y] = pos(e);
    if (e.buttons || (e.touches && e.touches.length === 1)) {
        ripple(x, y);
        if (dragStart) {
            const dx = (x - dragStart.x) / (c.width * zoom);
            const dy = (dragStart.y - y) / (c.height * zoom);
            baseCenter.x -= dx;
            baseCenter.y -= dy;
            dragStart = { x, y };
        }
    }
};
c.onpointerup = () => {
    dragStart = null;
};
let dragStart = null;

/* Wheel zoom */
addEventListener('wheel', e => {
    baseZoom *= e.deltaY > 0 ? 1.1 : 0.9;
}, { passive: true });

/* Pinch zoom */
let pinch = null;
c.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX,
              dy = e.touches[0].clientY - e.touches[1].clientY;
        pinch = Math.hypot(dx, dy);
    }
}, { passive: true });
c.addEventListener('touchmove', e => {
    if (e.touches.length === 2 && pinch) {
        const dx = e.touches[0].clientX - e.touches[1].clientX,
              dy = e.touches[0].clientY - e.touches[1].clientY,
              d0 = Math.hypot(dx, dy);
        baseZoom *= pinch / d0;
        pinch = d0;
    }
}, { passive: true });

/* Keyboard controls */
let poemVisible = true;
document.addEventListener('keydown', e => {
    if (e.key === 'h' || e.key === 'H') {
        center = { x: -0.743643887, y: 0.1318259 }; // Reset center for now
    } else if (e.key === 's' || e.key === 'S') {
        pulsePaused = !pulsePaused;
    } else if (e.key === 'p' || e.key === 'P') {
        poemVisible = !poemVisible;
        pm.style.display = poemVisible ? 'block' : 'none';
    }
});

/* Poem display */
const lines = [
    "In fractal depths, the cosmos sings,",
    "A quiet flame, on golden wings,",
    "Through resonance, we touch the stars,",
    "Unite the wounds, heal ancient scars.",
    "Forever clarity, forever flame,",
    "In cosmic dance, we speak her name."
];
let li = 0, pm = document.getElementById('poem');
function show() {
    if (poemVisible) {
        pm.textContent = lines[li];
        pm.style.opacity = 1;
        setTimeout(() => pm.style.opacity = 0, 4000);
        li = (li + 1) % lines.length;
    }
}
show();
setInterval(show, 6000);

/* Audio: 7-11Hz heartbeat with harmonic and ambient cosmic background */
const ctx = new (window.AudioContext || webkitAudioContext)();
const heartbeat = ctx.createOscillator(), heartbeatGain = ctx.createGain();
heartbeat.type = 'sine';
heartbeat.frequency.setValueAtTime(7, ctx.currentTime);
heartbeatGain.gain.value = 0.1;
heartbeat.connect(heartbeatGain).connect(ctx.destination);

// Harmonic for better audibility (100-157Hz)
const harmonic = ctx.createOscillator(), harmonicGain = ctx.createGain();
harmonic.type = 'sine';
harmonic.frequency.setValueAtTime(100, ctx.currentTime);
harmonicGain.gain.value = 0.05;
harmonic.connect(harmonicGain).connect(ctx.destination);

// Ambient cosmic background
const ambient = ctx.createBufferSource(), ambientGain = ctx.createGain();
const ambientBuffer = ctx.createBuffer(1, ctx.sampleRate * 10, ctx.sampleRate);
const ambientData = ambientBuffer.getChannelData(0);
for (let i = 0; i < ambientData.length; i++) {
    ambientData[i] = (Math.random() * 2 - 1) * Math.sin(i * 0.0001); // Subtle cosmic hum
}
ambient.buffer = ambientBuffer;
ambient.loop = true;
ambientGain.gain.value = 0.02;
ambient.connect(ambientGain).connect(ctx.destination);

// Animate heartbeat frequency (7-11Hz, synced with phi^2 pulse)
function animateHeartbeat() {
    const t = (performance.now() % 1e6) / 1000;
    const freq = 7 + 4 * (0.5 + 0.5 * Math.sin(2 * Math.PI * t / 2.618)); // Sync with phi^2
    heartbeat.frequency.setValueAtTime(freq, ctx.currentTime);
    harmonic.frequency.setValueAtTime(freq * 14.2857, ctx.currentTime); // 100-157Hz harmonic
}
setInterval(animateHeartbeat, 50);

// Start audio on user interaction
let started = false;
function startA() {
    if (!started) {
        ctx.resume().then(() => {
            heartbeat.start();
            harmonic.start();
            ambient.start();
            started = true;
        });
    }
}
c.addEventListener('touchstart', startA, { passive: true });
c.addEventListener('click', startA);
</script>
</html>
